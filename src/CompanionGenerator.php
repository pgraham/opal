<?php
/*
 * Copyright (c) 2014, Philip Graham
 * All rights reserved.
 *
 * This file is part of O-pal. For the full copyright and license information
 * please view the LICENSE file that was distributed with this source code.
 */
namespace zpt\opal;

use \zpt\pct\CodeTemplateParser;
use \zpt\pct\TemplateResolver;
use \SplFileObject;

/**
 * This class provides functionality for generating a companion object for a
 * class using a template.
 *
 * @author Philip Graham <philip@zeptech.ca>
 */
abstract class CompanionGenerator
{

    private $namingStrategy;
    private $outputPath;
    private $tmpl;

    /**
     * Create a new generator that outputs to the given path.  The given output
     * path is used as a base path.  The generation logic will append a PSR-0
     * compliant path to the specified path, taking into account both the value
     * of getCompanionNamespace() and the name of the companion as generated by
     * the NamingStrategy.
     *
     * # Example
     * For a class my\ns\Definition, the DefaultNamingStrategy and the following
     * implementation:
     *
     *     class MyGenerator extends AbstractGenerator {
     *         protected static $actorNamespace = 'my\dynamic\ns';
     *
     *         public function __construct() {
     *             parent::__construct('/path/to/site/target');
     *         }
     *
     *         protected function getCompanionNamespace() {
     *             return 'my\dynamic\ns';
     *         }
     *
     *         // ...
     *     }
     *
     * The companion will be my\dynamic\ns\my_ns_Definition and will output at
     * /path/to/site/target/my/dynamic/ns/my/ns/Definition.php
     *
     * @param string $outputPath The target path for the generated companion.
     */
    public function __construct($outputPath)
    {
        $this->outputPath = rtrim($outputPath, '/');
    }

    /**
     * Generate the code.  This method delegates to the implementation for the
     * acutal generation then outputs to the specified path.
     *
     * @param string $defClass The definition for which to generate an actor.
     */
    public function generate($defClass) {
        $this->init();

        $templatePath = $this->getTemplatePath($defClass);

        $companionNs = $this->getCompanionNamespace($defClass);
        $companionClass = $this->namingStrategy->getCompanionClassName(
            $defClass
        );
        $targetDir = $this->outputPath . '/' . $this->toPath($companionNs);
        $fileName = $this->toPath($companionClass);
        $outPath = $targetDir . '/' . $fileName . '.php';

        $values = $this->getValues($defClass);
        $values['companionNs'] = $companionNs;
        $values['companionClass'] = $companionClass;
        $values['model'] = $defClass;
        $values['modelStr'] = str_replace('\\', '\\\\', $defClass);

        $resolver = new TemplateResolver();
        $resolver->resolve($templatePath, $outPath, $values);
    }

    /**
     * Getter for the generator's naming strategy. Access is useful when
     * a companion class name needs to be determined outside of normal companion
     * generation and loading.
     *
     * @return NamingStrategy
     */
    public function getNamingStrategy() {
        return $this->namingStrategy;
    }

    /**
     * This method is responsible for returning the base namespace in which
     * companion object reside.
     *
     * @param string $defClass The name of the class for which a companion is
     *   being generated. This allows implementations to return different base
     *   namespaces for a possible hierarchy of definitions.
     * @return string
     */
    protected abstract function getCompanionNamespace($defClass);

    /**
     * This method is responsible for returning the path to the template that is
     * used to generate the actor.
     *
     * @param string $defClass The name of the class for which a companion is
     *   being generated. This allows implementations to return different
     *   templates for different definitions.
     * @return string
     */
    protected abstract function getTemplatePath($defClass);

    /**
     * This method is responsible for actually generating the substitution values
     * for generating the actor for the specified definition class.  These values
     * will be substituted into the template specified by getTemplatePath().
     *
     * @param string $defClass The name of the definition class.
     * @return array Substitution values for generating the actor.
     */
    protected abstract function getValues($defClass);

    /*
     * =========================================================================
     * Dependency setters
     * =========================================================================
     */

    public function setNamingStrategy(NamingStrategy $namingStrategy)
    {
        $this->namingStrategy = $namingStrategy;
    }

    /*
     * =========================================================================
     * Private helpers
     * =========================================================================
     */

    /* Ensure dependency are initialized */
    private function init() {
        // Ensure that injectable dependencies have an implementation available.
        if ($this->namingStrategy === null) {
            $this->namingStrategy = new DefaultNamingStrategy();
        }

        // If the template hasn't been set then initialize this instance
        if ($this->tmpl === null) {
        }
    }

    /* Convert the given namespace/classname to a path fragment. */
    private function toPath($name) {
        return str_replace(array('\\', '_'), '/', $name);
    }
}
